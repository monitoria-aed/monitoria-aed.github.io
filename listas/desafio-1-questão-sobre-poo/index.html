<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://kit.fontawesome.com/05efc4f42a.js" crossorigin="anonymous"></script>
    <link rel="stylesheet" href="/css/prism.css">
    <link rel="stylesheet" href="/css/single-lista.css">
    <link rel="stylesheet" href="/css/reset.css">
    <link rel="shortcut icon" href="/img/favicon.ico" type="image/x-icon">
    <script src="https://identity.netlify.com/v1/netlify-identity-widget.js"></script>
    <title>Desafio #1 - Quest√£o sobre POO Algoritmos e Estrutura de Dados</title>
</head>
<body>
    
    <main>
       
<header>
    <a href="../">Algoritmos e Estruturas de Dados</a>
    <nav>
    <ul>
        <li><a href="../">Home</a></li>
        <li><a href="../monitoria">Monitoria</a></li>
        <li><a href="../sobre">Sobre</a></li>
    </ul>
</nav>
</header>

<div class="container">
    <div class="post-info">
        <h1>Desafio #1 - Quest√£o sobre POO</h1>
        <ul>
            <li><p><i class="fa-solid fa-user"></i> Luiz Eduardo</p></li>
            <li><p><i class="fa-solid fa-calendar"></i> Jun 30, 2022</p></li>
        </ul>
    </div>

    <div class="content">
        <p>Como dito em aula os desafios s√£o quest√µes de provas retiradas dos semestres anteriores, valendo ponto extra. Portanto, al√©m de uma √≥tima forma de voc√™ treinar, conhecer os modelos de perguntas cobradas em provas, e ainda por cima ganhar uma notinha extra, √© tamb√©m uma forma de voc√™ averiguar quanto tempo voc√™s levam para resolv√™-lo, o que √© important√≠ssimo, afinal voc√™s ter√£o no m√°ximo duas horas para responder tr√™s ou mais quest√µes desse tipo.</p>
<p>Aqui voc√™ vai encontrar uma solu√ß√£o proposta por um dos monitores, com algumas explica√ß√µes sobre o c√≥digo. Se voc√™ n√£o conseguiu resolver, tente copiar essa quest√£o (ao inv√©s de usar o Ctrl + C, Ctrl + V) e ir explicando para si mesmo o que cada linha significa, isso o ajudar√° a internalizar determinados conceitos.</p>
<p>Ent√£o, vamos l√° üòâ.</p>

    </div>

    
        <div class="questao">
            <p>Criamos a classe ContaCorrente, conforme pedido no enunciado do desafio e declaramos os atributos privados: nome, cpf, saldo e quantia (lembre-se que n√£o √© necess√°rio utilizara palavra reservada `private`, pois por padr√£o o C++ reconhece que qualquer atributo que seja declarado estando fora do escopo de `public`ou `protected `√© `private`.

Na parte p√∫blica do c√≥digo separamos em tr√™s: os m√©todos pedidos pela quest√£o, os *getters* e os *setters* dos atributos privados. Os m√©todos requisitados foram implementados fora do esqueleto da classe, isso √©: fora do bloco da ContaCorrente, tal escolha foi feita para poder trabalhar mais livremente o c√≥digo, deixar a estrutura da classe mais limpa e leg√≠vel, e mostra-los uma forma diferente de declarar e inicializar m√©todos de classes. Os outros dois, *getters* e *setters* , foram implementados de acordo com o padr√£o.</p>
            
            <pre >
                <code class="language-cpp">
                    
class ContaCorrente{
    //Atributos
    string nome;
    int cpf;
    float saldo;
    float quantia;

    public:
    // M√©todos p√∫blicos
    void cadastrarCliente();
    void depositar();
    void sacar();
    void obterSaldo(); 

    // getters
    string getNome() { return nome; }
    int getCpf(){ return cpf; }
    float getSaldo(){ return saldo; }
    float getQuantia(){ return quantia; }
    
    // setters
    void setNome( string Nome ){ nome = Nome; }
    void setCpf( int CPF ){ cpf = CPF; }
    void setSaldo( float Saldo ){ saldo = Saldo;} 
    void setQuantia( float Quantia ){ quantia = Quantia; }
};

void ContaCorrente::cadastrarCliente(){
    string auxNome;
    int auxCpf;

    cout &lt;&lt; &quot;Digite o nome: \n&quot;;
    cin &gt;&gt; auxNome;
    cout &lt;&lt; &quot;Digite o CPF: \n&quot;;
    cin &gt;&gt; auxCpf;

    this-&gt;setNome(auxNome);
    this-&gt;setCpf(auxCpf);
    this-&gt;setQuantia(0);
    this-&gt;setSaldo(0);
}

void ContaCorrente::depositar(){
    cout &lt;&lt; &quot;Digite a quantia para deposito: \n&quot;;
    cin &gt;&gt; quantia;

    //Para atualizar o saldo a cada dep√≥sito basta
    //pegar o valor atual e somar com o valor de dep√≥sito.
    this-&gt;setSaldo( this-&gt;getSaldo() + this-&gt;getQuantia() );
}

void ContaCorrente::sacar(){

    cout &lt;&lt; &quot;Digite a quantia para saque: \n&quot;;
    cin &gt;&gt; quantia;

    // Aplicamos a taxa para sacar sobre a quantia 
    // retirada.
    this-&gt;setSaldo(
        this-&gt;getSaldo() - (quantia * 0.05 + quantia)
    );
}

void ContaCorrente::obterSaldo(){
    cout &lt;&lt; &quot;O saldo eh: &quot; &lt;&lt; this-&gt;getSaldo() &lt;&lt; endl;
}
                </code>
            </pre>
        </div>
    
        <div class="questao">
            <p>Como iremos trabalhar com um *array* de objetos, resolvi criar transformar o *loop* sobre esse array em uma fun√ß√£o, uma vez que ele √© utilizado em tr√™s das quatro op√ß√µes do menu. 

Essa fun√ß√£o itera sobre o array de clientes, do tipo ContaCorrente, se houver mais de um cliente cadastrado, por isso a condicional no c√≥digo. Na computa√ß√£o o valor de 0 √© equivalente a **false,** e qualquer n√∫mero **maior que 0** √© equivalente a **true.** Portanto se o tamanho do array for de um s√≥ elemento (um ind√≠ce s√≥) o c√≥digo dentro da condicional n√£o ser√° executado, caso o array possua mais de um elemento, o c√≥digo ser√° executado.

A vari√°vel cliente recebe o valor de 0 no in√≠cio, pois no caso de o tamanho do array for de um s√≥ elemento retornaremos o √≠ndice do primeiro elemento, ou seja, 0.</p>
            
            <pre >
                <code class="language-cpp">
                    
int listarClientes(ContaCorrente arr[], int n, string opcao){
    int cliente = 0;

    if(n){
        for(int j = 0; j &lt; n; j++){
            cout &lt;&lt; j &lt;&lt; &quot; - &quot; &lt;&lt; arr[j].getNome() &lt;&lt; endl;
        }

        cout &lt;&lt; &quot;Para qual cliente deseja &quot; &lt;&lt; opcao &lt;&lt;&quot;?\n&quot;;
        cin &gt;&gt; cliente;
    }

    return cliente;
}

                </code>
            </pre>
        </div>
    
        <div class="questao">
            <p>Por fim, a fun√ß√£o `main` que instancia um array de 100 posi√ß√µes, `ContaCorrente clientes[100]`**,** e uma vari√°vel `i= 0 `que funcionar√° como ponteiro para o nosso array, apontando para qual posi√ß√£o o √∫ltimo cliente cadastrado foi armazenado no array `clientes. `Alguns dos `cases` possuem chaves, essas chaves s√£o utilizadas para criar um escopo no c√≥digo e impedir que haja conflito as tr√™s declara√ß√µes da vari√°vel `cliente`. 

Por fim, utilizamos a fun√ß√£o `exit(0) `para finalizar o programa.

D√∫vidas? Contate o seu monitor atrav√©s da plataforma Teams.

At√© mais! üëã</p>
            
            <pre >
                <code class="language-cpp">
                    
int main(){
    ContaCorrente clientes[100];
    int i = 0; 

    while(true){
        int resposta;

        cout &lt;&lt; &quot;1 - Cadastrar cliente\n&quot;;
        cout &lt;&lt; &quot;2 - Depositar\n&quot;;
        cout &lt;&lt; &quot;3 - Sacar\n&quot;;
        cout &lt;&lt; &quot;4 - Obter saldo\n&quot;;
        cout &lt;&lt; &quot;5 - Sair\n&quot;;
        cin &gt;&gt; resposta;
        
        switch (resposta)
        {
            case 1:
                if(i &lt; 100){
                    clientes[i].cadastrarCliente();
                    i++;
                }
                break;

            case 2:{
                int cliente = listarClientes(clientes, i, &quot;depositar&quot;);
                clientes[cliente].depositar();
                break;
            }
                
            case 3:{
                int cliente = listarClientes(clientes, i, &quot;sacar&quot;);
                clientes[cliente].sacar();
                break;
            }
            
            case 4:{
                int cliente = listarClientes(clientes, i, &quot;obter o saldo&quot;);
                clientes[cliente].obterSaldo();
                break;
            } 
            
            default:
                exit(0);
        }

    }
}
                </code>
            </pre>
        </div>
    
</div>

    </main>
 
    <footer>
    <p>Mantido com ‚ù§ pelos monitores. <br>Desenvolvido por <a href="http://luizerl.com">Luiz Eduardo.</a></p>
</footer>

    <script>
  if (window.netlifyIdentity) {
    window.netlifyIdentity.on("init", user => {
      if (!user) {
        window.netlifyIdentity.on("login", () => {
          document.location.href = "/admin/";
        });
      }
    });
  }
</script>
<script src="/script/prism.js"></script>

</body>
</html>